// Copyright 2013, Big Switch Networks, Inc.
//
// LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
// the following special exception:
//
// LOXI Exception
//
// As a special exception to the terms of the EPL, you may distribute libraries
// generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
// that copyright and licensing notices generated by LoxiGen are not altered or removed
// from the LoxiGen Libraries and the notice provided below is (i) included in
// the LoxiGen Libraries, if distributed in source code form and (ii) included in any
// documentation for the LoxiGen Libraries, if distributed in binary form.
//
// Notice: "Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
//
// You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
// a copy of the EPL at:
//
// http://www.eclipse.org/legal/epl-v10.html
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// EPL for the specific language governing permissions and limitations
// under the EPL.
//
// Also derived from the OpenFlow header files which have these copyrights:
// Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University
// Copyright (c) 2011, 2012 Open Networking Foundation

#version 1

enum macro_definitions {
    OFP_MAX_TABLE_NAME_LEN = 32,
    OFP_MAX_PORT_NAME_LEN = 16,

    OFP_TCP_PORT = 6633,
    OFP_SSL_PORT = 6633,

    OFP_ETH_ALEN = 6,

    OFP_DEFAULT_MISS_SEND_LEN = 128,

    OFP_VLAN_NONE = 0xffff,

    OFPFW_ICMP_TYPE = 0x40,
    OFPFW_ICMP_CODE = 0x80,

    OFP_DL_TYPE_ETH2_CUTOFF = 0x600,
    OFP_DL_TYPE_NOT_ETH_TYPE = 0x5ff,

    OFP_FLOW_PERMANENT = 0,

    OFP_DEFAULT_PRIORITY = 0x8000,

    DESCRIPTION_STRING_LEN = 256,
    SERIAL_NUMBER_LEN = 32,

    OFPQ_ALL = 0xffffffff,
    OFPQ_MIN_RATE_UNCFG = 0xffff,
};

enum ofp_message_type(wire_type=uint8_t) {
    OFPT_HELLO = 0,
    OFPT_ERROR = 1,
    OFPT_ECHO_REQUEST = 2,
    OFPT_ECHO_REPLY = 3,
    OFPT_VENDOR = 4,
    OFPT_FEATURES_REQUEST = 5,
    OFPT_FEATURES_REPLY = 6,
    OFPT_GET_CONFIG_REQUEST = 7,
    OFPT_GET_CONFIG_REPLY = 8,
    OFPT_SET_CONFIG = 9,
    OFPT_PACKET_IN = 10,
    OFPT_FLOW_REMOVED = 11,
    OFPT_PORT_STATUS = 12,
    OFPT_PACKET_OUT = 13,
    OFPT_FLOW_MOD = 14,
    OFPT_PORT_MOD = 15,
    OFPT_STATISTICS_REQUEST = 16,
    OFPT_STATISTICS_REPLY = 17,
    OFPT_BARRIER_REQUEST = 18,
    OFPT_BARRIER_REPLY = 19,
    OFPT_QUEUE_GET_CONFIG_REQUEST = 20,
    OFPT_QUEUE_GET_CONFIG_REPLY = 21,
};

enum ofp_port_config(wire_type=uint32_t, bitmask=True) {
    OFPPC_PORT_DOWN = 0x1,
    OFPPC_NO_STP = 0x2,
    OFPPC_NO_RECV = 0x4,
    OFPPC_NO_RECV_STP = 0x8,
    OFPPC_NO_FLOOD = 0x10,
    OFPPC_NO_FWD = 0x20,
    OFPPC_NO_PACKET_IN = 0x40,
};

enum ofp_port_state(wire_type=uint32_t, bitmask=True) {
    OFPPS_STP_LISTEN = 0,
    OFPPS_LINK_DOWN = 1,
    OFPPS_STP_LEARN = 0x100,
    OFPPS_STP_FORWARD = 0x200,
    OFPPS_STP_BLOCK = 0x300,
    OFPPS_STP_MASK(virtual=True) = 0x300,
};

// FIXME: these constants are currently 32 bit due to implementation
// details of loci, which is in violation of the OpenFlow spec.
// Should recast to 32 bits and fix/glue the c backend
enum ofp_port_no(wire_type=uint16_t, complete=False) {
    OFPP_MAX = 0xffffff00,
    OFPP_IN_PORT = 0xfffffff8,
    OFPP_TABLE = 0xfffffff9,
    OFPP_NORMAL = 0xfffffffa,
    OFPP_FLOOD = 0xfffffffb,
    OFPP_ALL = 0xfffffffc,
    OFPP_CONTROLLER = 0xfffffffd,
    OFPP_LOCAL = 0xfffffffe,
    OFPP_NONE = 0xffffffff,
};

enum ofp_port_features(wire_type=uint32_t, bitmask=True) {
    OFPPF_10MB_HD = 0x1,
    OFPPF_10MB_FD = 0x2,
    OFPPF_100MB_HD = 0x4,
    OFPPF_100MB_FD = 0x8,
    OFPPF_1GB_HD = 0x10,
    OFPPF_1GB_FD = 0x20,
    OFPPF_10GB_FD = 0x40,
    OFPPF_COPPER = 0x80,
    OFPPF_FIBER = 0x100,
    OFPPF_AUTONEG = 0x200,
    OFPPF_PAUSE = 0x400,
    OFPPF_PAUSE_ASYM = 0x800,
};

enum ofp_queue_property_type(wire_type=uint32_t) {
    OFPQT_NONE = 0,
    OFPQT_MIN_RATE = 1,
};

enum ofp_flow_wildcards(wire_type=uint32_t, bitmask=True) {
    OFPFW_IN_PORT = 0x1,
    OFPFW_DL_VLAN = 0x2,
    OFPFW_DL_SRC = 0x4,
    OFPFW_NW_DST_BITS = 0x6,
    OFPFW_NW_SRC_BITS = 0x6,
    OFPFW_NW_SRC_SHIFT = 0x8,
    OFPFW_DL_DST = 0x8,
    OFPFW_NW_DST_SHIFT = 0xe,
    OFPFW_DL_TYPE = 0x10,
    OFPFW_NW_PROTO = 0x20,
    OFPFW_TP_SRC = 0x40,
    OFPFW_TP_DST = 0x80,
    OFPFW_NW_SRC_ALL = 0x2000,
    OFPFW_NW_SRC_MASK = 0x3f00,
    OFPFW_NW_DST_ALL = 0x80000,
    OFPFW_NW_DST_MASK = 0xfc000,
    OFPFW_DL_VLAN_PCP = 0x100000,
    OFPFW_NW_TOS = 0x200000,
    OFPFW_ALL = 0x3fffff,
};

enum ofp_action_type(wire_type=uint16_t) {
    OFPAT_OUTPUT = 0,
    OFPAT_SET_VLAN_ID = 1,
    OFPAT_SET_VLAN_PCP = 2,
    OFPAT_STRIP_VLAN = 3,
    OFPAT_SET_DL_SRC = 4,
    OFPAT_SET_DL_DST = 5,
    OFPAT_SET_NW_SRC = 6,
    OFPAT_SET_NW_DST = 7,
    OFPAT_SET_NW_TOS = 8,
    OFPAT_SET_TP_SRC = 9,
    OFPAT_SET_TP_DST = 10,
    OFPAT_OPAQUE_ENQUEUE = 11,
    OFPAT_VENDOR = 0xffff,
};

enum ofp_capabilities(wire_type=uint32_t, bitmask=True) {
    OFPC_FLOW_STATS = 0x1,
    OFPC_TABLE_STATS = 0x2,
    OFPC_PORT_STATS = 0x4,
    OFPC_STP = 0x8,
    OFPC_RESERVED = 0x10,
    OFPC_IP_REASM = 0x20,
    OFPC_QUEUE_STATS = 0x40,
    OFPC_ARP_MATCH_IP = 0x80,
};

enum ofp_config_flags(wire_type=uint32_t, bitmask=True) {
    OFPC_FRAG_NORMAL = 0x0,
    OFPC_FRAG_DROP = 0x1,
    OFPC_FRAG_REASM = 0x2,
    OFPC_FRAG_MASK = 0x3,
};

enum ofp_flow_mod_command(wire_type=uint16_t) {
    OFPFC_ADD = 0,
    OFPFC_MODIFY = 1,
    OFPFC_MODIFY_STRICT = 2,
    OFPFC_DELETE = 3,
    OFPFC_DELETE_STRICT = 4,
};

enum ofp_flow_mod_flags(wire_type=uint16_t, bitmask=True) {
    OFPFF_SEND_FLOW_REM = 0x1,
    OFPFF_CHECK_OVERLAP = 0x2,
    OFPFF_EMERG = 0x4,
};

enum ofp_stats_reply_flags(wire_type=uint16_t, bitmask=True) {
    OFPSF_REPLY_MORE = 0x1,
};

enum ofp_statistics_type(wire_type=uint16_t, request=ofp_message_type.OFPT_STATISTICS_REQUEST, reply=ofp_message_type.OFPT_STATISTICS_REPLY) {
    OFPST_DESC = 0,
    OFPST_FLOW = 1,
    OFPST_AGGREGATE = 2,
    OFPST_TABLE = 3,
    OFPST_PORT = 4,
    OFPST_QUEUE = 5,
    OFPST_VENDOR = 0xffff,
};

// added for compliance with 1.3 >= 
enum ofp_statistics_request_flags(wire_type=uint16_t, bitmask=True) {
	OFPMPF_REQ_NONE = 0x0,
};

// added for compliance with 1.3 >=
enum ofp_statistics_reply_flags(wire_type=uint16_t, bitmask=True) {
	OFPMPF_REPLY_NONE = 0x0,
};

enum ofp_packet_in_reason(wire_type=uint8_t) {
    OFPR_NO_MATCH = 0,
    OFPR_ACTION = 1,
};

enum ofp_flow_removed_reason(wire_type=uint8_t) {
    OFPRR_IDLE_TIMEOUT = 0,
    OFPRR_HARD_TIMEOUT = 1,
    OFPRR_DELETE = 2,
};

enum ofp_port_reason(wire_type=uint8_t) {
    OFPPR_ADD = 0,
    OFPPR_DELETE = 1,
    OFPPR_MODIFY = 2,
};

enum ofp_error_code(wire_type=uint16_t) {
    OFPET_HELLO_FAILED = 0,
    OFPET_BAD_REQUEST = 1,
    OFPET_BAD_ACTION = 2,
    OFPET_FLOW_MOD_FAILED = 3,
    OFPET_PORT_MOD_FAILED = 4,
    OFPET_QUEUE_OP_FAILED = 5,
};

enum ofp_hello_failed_code(wire_type=uint16_t) {
    OFPHFC_INCOMPATIBLE = 0,
    OFPHFC_EPERM = 1,
};

enum ofp_bad_request_code(wire_type=uint16_t) {
    OFPBRC_BAD_VERSION = 0,
    OFPBRC_BAD_TYPE = 1,
    OFPBRC_BAD_STAT = 2,
    OFPBRC_BAD_VENDOR = 3,
    OFPBRC_BAD_SUBTYPE = 4,
    OFPBRC_EPERM = 5,
    OFPBRC_BAD_LEN = 6,
    OFPBRC_BUFFER_EMPTY = 7,
    OFPBRC_BUFFER_UNKNOWN = 8,
};

enum ofp_bad_action_code(wire_type=uint16_t) {
    OFPBAC_BAD_TYPE = 0,
    OFPBAC_BAD_LEN = 1,
    OFPBAC_BAD_VENDOR = 2,
    OFPBAC_BAD_VENDOR_TYPE = 3,
    OFPBAC_BAD_OUT_PORT = 4,
    OFPBAC_BAD_ARGUMENT = 5,
    OFPBAC_EPERM = 6,
    OFPBAC_TOO_MANY = 7,
    OFPBAC_BAD_QUEUE = 8,
};

enum ofp_flow_mod_failed_code(wire_type=uint16_t) {
    OFPFMFC_ALL_TABLES_FULL = 0,
    OFPFMFC_OVERLAP = 1,
    OFPFMFC_EPERM = 2,
    OFPFMFC_BAD_EMERG_TIMEOUT = 3,
    OFPFMFC_BAD_COMMAND = 4,
    OFPFMFC_UNSUPPORTED = 5,
};

enum ofp_port_mod_failed_code(wire_type=uint16_t) {
    OFPPMFC_BAD_PORT = 0,
    OFPPMFC_BAD_HW_ADDR = 1,
};

enum ofp_queue_op_failed_code(wire_type=uint16_t) {
    OFPQOFC_BAD_PORT = 0,
    OFPQOFC_BAD_QUEUE = 1,
    OFPQOFC_EPERM = 2,
};

/* XXX rename to of_message */
struct of_header {
    uint8_t version == 0x01;
    uint8_t type == ?;
    uint16_t length;
    uint32_t xid;
};

struct of_hello : of_header {
    uint8_t version;
    uint8_t type == 0;
    uint16_t length;
    uint32_t xid;
};

struct of_echo_request : of_header {
    uint8_t version;
    uint8_t type == 2;
    uint16_t length;
    uint32_t xid;
    of_octets_t data;
};

struct of_echo_reply : of_header {
    uint8_t version;
    uint8_t type == 3;
    uint16_t length;
    uint32_t xid;
    of_octets_t data;
};

struct of_vendor : of_header {
    uint8_t version;
    uint8_t type == 4;
    uint16_t length;
    uint32_t xid;
    uint32_t vendor_id == ?;
    uint32_t subtype;
    of_octets_t data;
};

struct of_barrier_request : of_header {
    uint8_t version;
    uint8_t type == 18;
    uint16_t length;
    uint32_t xid;
};

struct of_barrier_reply : of_header {
    uint8_t version;
    uint8_t type == 19;
    uint16_t length;
    uint32_t xid;
};

struct of_get_config_request : of_header {
    uint8_t version;
    uint8_t type == 7;
    uint16_t length;
    uint32_t xid;
};

struct of_get_config_reply : of_header {
    uint8_t version;
    uint8_t type == 8;
    uint16_t length;
    uint32_t xid;
    uint16_t flags;
    uint16_t miss_send_length;
};

struct of_set_config : of_header {
    uint8_t version;
    uint8_t type == 9;
    uint16_t length;
    uint32_t xid;
    uint16_t flags;
    uint16_t miss_send_length;
};

struct of_port_desc {
    uint16_t port;
    of_mac_addr_t hw_addr;
    of_port_name_t name;
    of_port_config_t config;
    of_port_state_t state;
    uint32_t current_features;
    uint32_t advertised_features;
    uint32_t supported_features;
    uint32_t peer_features;
};

struct of_features_request : of_header {
    uint8_t version;
    uint8_t type == 5;
    uint16_t length;
    uint32_t xid;
};

struct of_features_reply : of_header {
    uint8_t version;
    uint8_t type == 6;
    uint16_t length;
    uint32_t xid;
    uint64_t datapath_id;
    uint32_t n_buffers;
    uint8_t n_tables;
    pad(3);
    uint32_t capabilities;
    uint32_t actions;
    list(of_port_desc_t) ports;
};

struct of_port_status : of_header {
    uint8_t version;
    uint8_t type == 12;
    uint16_t length;
    uint32_t xid;
    of_port_reason_t reason;
    pad(7);
    of_port_desc_t desc;
};

struct of_port_mod : of_header {
    uint8_t version;
    uint8_t type == 15;
    uint16_t length;
    uint32_t xid;
    uint16_t port_no;
    of_mac_addr_t hw_addr;
    uint32_t config;
    uint32_t mask;
    uint32_t advertise;
    pad(4);
};

struct of_packet_in : of_header {
    uint8_t version;
    uint8_t type == 10;
    uint16_t length;
    uint32_t xid;
    uint32_t buffer_id;
    uint16_t total_length;
    uint16_t input_port;
    uint8_t reason;
    pad(1);
    of_octets_t data;
};

struct of_action {
    uint16_t type == ?;
    uint16_t length;
};

struct of_action_output : of_action {
    uint16_t type == 0;
    uint16_t length;
    uint16_t port;
    uint16_t max_length;
};

struct of_action_set_vlan_id : of_action {
    uint16_t type == 1;
    uint16_t length;
    uint16_t vlan_id;
    pad(2);
};

struct of_action_strip_vlan : of_action {
    uint16_t type == 3;
    uint16_t length;
    pad(4);
};

struct of_action_set_vlan_pcp : of_action {
    uint16_t type == 2;
    uint16_t length;
    uint8_t vlan_pcp;
    pad(3);
};

struct of_action_set_dl_src : of_action {
    uint16_t type == 4;
    uint16_t length;
    of_mac_addr_t dl_addr;
    pad(6);
};

struct of_action_set_dl_dst : of_action {
    uint16_t type == 5;
    uint16_t length;
    of_mac_addr_t dl_addr;
    pad(6);
};

struct of_action_set_nw_src : of_action {
    uint16_t type == 6;
    uint16_t length;
    uint32_t nw_addr;
};

struct of_action_set_nw_dst : of_action {
    uint16_t type == 7;
    uint16_t length;
    uint32_t nw_addr;
};

struct of_action_set_tp_src : of_action {
    uint16_t type == 9;
    uint16_t length;
    uint16_t tp_port;
    pad(2);
};

struct of_action_set_tp_dst : of_action {
    uint16_t type == 10;
    uint16_t length;
    uint16_t tp_port;
    pad(2);
};

struct of_action_set_nw_tos : of_action {
    uint16_t type == 8;
    uint16_t length;
    uint8_t nw_tos;
    pad(3);
};

struct of_action_vendor : of_action {
    uint16_t type == 65535;
    uint16_t length;
    uint32_t vendor_id == ?;
    of_octets_t data;
};

struct of_action_opaque_enqueue : of_action {
    uint16_t type == 11;
    uint16_t length;
    uint16_t port;
    pad(6);
    uint32_t queue_id;
};

struct of_packet_out : of_header {
    uint8_t version;
    uint8_t type == 13;
    uint16_t length;
    uint32_t xid;
    uint32_t buffer_id;
    uint16_t input_port;
    uint16_t actions_length;
    list(of_action_t) actions;
    of_octets_t data;
};

struct of_match {
    of_flow_wildcards_t wildcards;
    uint16_t input_port;
    of_mac_addr_t data_layer_source;
    of_mac_addr_t data_layer_destination;
    uint16_t data_layer_virtual_lan;
    uint8_t data_layer_virtual_lan_priority_code_point;
    pad(1);
    uint16_t data_layer_type;
    uint8_t network_type_of_service;
    uint8_t network_protocol;
    pad(2);
    of_ipv4_t network_source;
    of_ipv4_t network_destination;
    uint16_t transport_source;
    uint16_t transport_destination;
};

struct of_flow_mod : of_header {
    uint8_t version;
    uint8_t type == 14;
    uint16_t length;
    uint32_t xid;
    of_match_t match;
    uint64_t cookie;
    of_flow_mod_command_t command == ?;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    uint16_t priority;
    uint32_t buffer_id;
    uint16_t out_port;
    uint16_t flags;
    list(of_action_t) actions;
};

struct of_flow_add : of_flow_mod {
    uint8_t version;
    uint8_t type == 14;
    uint16_t length;
    uint32_t xid;
    of_match_t match;
    uint64_t cookie;
    of_flow_mod_command_t command == 0;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    uint16_t priority;
    uint32_t buffer_id;
    uint16_t out_port;
    uint16_t flags;
    list(of_action_t) actions;
};

struct of_flow_modify : of_flow_mod {
    uint8_t version;
    uint8_t type == 14;
    uint16_t length;
    uint32_t xid;
    of_match_t match;
    uint64_t cookie;
    of_flow_mod_command_t command == 1;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    uint16_t priority;
    uint32_t buffer_id;
    uint16_t out_port;
    uint16_t flags;
    list(of_action_t) actions;
};

struct of_flow_modify_strict : of_flow_mod {
    uint8_t version;
    uint8_t type == 14;
    uint16_t length;
    uint32_t xid;
    of_match_t match;
    uint64_t cookie;
    of_flow_mod_command_t command == 2;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    uint16_t priority;
    uint32_t buffer_id;
    uint16_t out_port;
    uint16_t flags;
    list(of_action_t) actions;
};

struct of_flow_delete : of_flow_mod {
    uint8_t version;
    uint8_t type == 14;
    uint16_t length;
    uint32_t xid;
    of_match_t match;
    uint64_t cookie;
    of_flow_mod_command_t command == 3;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    uint16_t priority;
    uint32_t buffer_id;
    uint16_t out_port;
    uint16_t flags;
    list(of_action_t) actions;
};

struct of_flow_delete_strict : of_flow_mod {
    uint8_t version;
    uint8_t type == 14;
    uint16_t length;
    uint32_t xid;
    of_match_t match;
    uint64_t cookie;
    of_flow_mod_command_t command == 4;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    uint16_t priority;
    uint32_t buffer_id;
    uint16_t out_port;
    uint16_t flags;
    list(of_action_t) actions;
};

struct of_flow_removed : of_header {
    uint8_t version;
    uint8_t type == 11;
    uint16_t length;
    uint32_t xid;
    of_match_t match;
    uint64_t cookie;
    uint16_t priority;
    uint8_t reason;
    pad(1);
    uint32_t duration_sec;
    uint32_t duration_nsec;
    uint16_t idle_timeout;
    pad(2);
    uint64_t packet_count;
    uint64_t byte_count;
};

struct of_error : of_header {
    uint8_t version;
    uint8_t type == 1;
    uint16_t length;
    uint32_t xid;
    uint16_t error_code;
    uint16_t subcode;
    of_octets_t data;
};

// STATS ENTRIES: flow, table, port, queue,
struct of_flow_stats_entry {
    uint16_t length;
    uint8_t table_id;
    pad(1);
    of_match_t match;
    uint32_t duration_sec;
    uint32_t duration_nsec;
    uint16_t priority;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    pad(6);
    uint64_t cookie;
    uint64_t packet_count;
    uint64_t byte_count;
    list(of_action_t) actions;
};

struct of_table_stats_entry {
    uint8_t table_id;
    pad(3);
    of_table_name_t name;
    of_flow_wildcards_t wildcards;
    uint32_t max_entries;
    uint32_t active_count;
    uint64_t lookup_count;
    uint64_t matched_count;
};

struct of_port_stats_entry {
    uint16_t port_number;
    pad(6);
    uint64_t receive_packets;
    uint64_t transmit_packets;
    uint64_t receive_bytes;
    uint64_t transmit_bytes;
    uint64_t receive_dropped;
    uint64_t transmit_dropped;
    uint64_t receive_errors;
    uint64_t transmit_errors;
    uint64_t receive_frame_errors;
    uint64_t receive_overrun_errors;
    uint64_t receive_CRC_err;
    uint64_t collisions;
};

struct of_queue_stats_entry {
    uint16_t port_number;
    pad(2);
    uint32_t queue_id;
    uint64_t transmit_bytes;
    uint64_t transmit_packets;
    uint64_t transmit_errors;
};

// STATS request/reply:  Desc, flow, agg, table, port, queue

struct of_statistics : of_header {
	uint8_t version;
    uint8_t type == ?;
    uint16_t length;
    uint32_t xid;
};

struct of_statistics_request : of_statistics {
    uint8_t version;
    uint8_t type == 16;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == ?;
    uint16_t flags;
};

struct of_statistics_reply : of_statistics {
    uint8_t version;
    uint8_t type == 17;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == ?;
    uint16_t flags;
};

struct of_statistics_desc_request : of_statistics_request {
    uint8_t version;
    uint8_t type == 16;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 0;
    uint16_t flags;
};

struct of_statistics_desc_reply : of_statistics_reply {
    uint8_t version;
    uint8_t type == 17;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 0;
    uint16_t flags;
    of_desc_str_t manufacturer_description;
    of_desc_str_t hardware_description;
    of_desc_str_t software_description;
    of_serial_num_t serial_number;
    of_desc_str_t datapath_description;
};

struct of_statistics_flow_request : of_statistics_request {
    uint8_t version;
    uint8_t type == 16;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 1;
    uint16_t flags;
    of_match_t match;
    uint8_t table_id;
    pad(1);
    uint16_t out_port;
};

struct of_statistics_flow_reply : of_statistics_reply {
    uint8_t version;
    uint8_t type == 17;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 1;
    uint16_t flags;
    list(of_flow_stats_entry_t) entries;
};

struct of_statistics_aggregate_request : of_statistics_request {
    uint8_t version;
    uint8_t type == 16;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 2;
    uint16_t flags;
    of_match_t match;
    uint8_t table_id;
    pad(1);
    uint16_t out_port;
};

struct of_statistics_aggregate_reply : of_statistics_reply {
    uint8_t version;
    uint8_t type == 17;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 2;
    uint16_t flags;
    uint64_t packet_count;
    uint64_t byte_count;
    uint32_t flow_count;
    pad(4);
};

struct of_statistics_table_request : of_statistics_request {
    uint8_t version;
    uint8_t type == 16;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 3;
    uint16_t flags;
};

struct of_statistics_table_reply : of_statistics_reply {
    uint8_t version;
    uint8_t type == 17;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 3;
    uint16_t flags;
    list(of_table_stats_entry_t) entries;
};

struct of_statistics_port_request : of_statistics_request {
    uint8_t version;
    uint8_t type == 16;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 4;
    uint16_t flags;
    uint16_t port;
    pad(6);
};

struct of_statistics_port_reply : of_statistics_reply {
    uint8_t version;
    uint8_t type == 17;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 4;
    uint16_t flags;
    list(of_port_stats_entry_t) entries;
};

struct of_statistics_queue_request : of_statistics_request {
    uint8_t version;
    uint8_t type == 16;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 5;
    uint16_t flags;
    uint16_t port_no;
    pad(2);
    uint32_t queue_id;
};

struct of_statistics_queue_reply : of_statistics_reply {
    uint8_t version;
    uint8_t type == 17;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 5;
    uint16_t flags;
    list(of_queue_stats_entry_t) entries;
};

struct of_statistics_vendor_request : of_statistics_request {
    uint8_t version;
    uint8_t type == 16;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 0xffff;
    uint16_t flags;
    uint32_t vendor == ?;
    of_octets_t data;
};

struct of_statistics_vendor_reply : of_statistics_reply {
    uint8_t version;
    uint8_t type == 17;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 0xffff;
    uint16_t flags;
    uint32_t vendor == ?;
    of_octets_t data;
};

// END OF STATS OBJECTS

struct of_queue_property {
    uint16_t type == ?;
    uint16_t length;
    pad(4);
};

struct of_queue_property_none : of_queue_property {
	uint16_t type == 0;
    uint16_t length;
    pad(4);
};

struct of_queue_property_min_rate : of_queue_property {
    uint16_t type == 1;
    uint16_t length;
    pad(4);
    uint16_t rate;
    pad(6);
};

struct of_packet_queue {
    uint32_t queue_id;
    uint16_t length;
    pad(2);
    list(of_queue_property_t) properties;
};

struct of_queue_get_config_request : of_header {
    uint8_t version;
    uint8_t type == 20;
    uint16_t length;
    uint32_t xid;
    uint16_t port;
    pad(2);
};

struct of_queue_get_config_reply : of_header {
    uint8_t version;
    uint8_t type == 21;
    uint16_t length;
    uint32_t xid;
    uint16_t port;
    pad(6);
    list(of_packet_queue_t) queues;
};