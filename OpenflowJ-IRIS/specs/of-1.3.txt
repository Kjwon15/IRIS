// Copyright 2013, Big Switch Networks, Inc.
//
// LoxiGen is licensed under the Eclipse Public License, version 1.0 (EPL), with
// the following special exception:
//
// LOXI Exception
//
// As a special exception to the terms of the EPL, you may distribute libraries
// generated by LoxiGen (LoxiGen Libraries) under the terms of your choice, provided
// that copyright and licensing notices generated by LoxiGen are not altered or removed
// from the LoxiGen Libraries and the notice provided below is (i) included in
// the LoxiGen Libraries, if distributed in source code form and (ii) included in any
// documentation for the LoxiGen Libraries, if distributed in binary form.
//
// Notice: "Copyright 2013, Big Switch Networks, Inc. This library was generated by the LoxiGen Compiler."
//
// You may not use this file except in compliance with the EPL or LOXI Exception. You may obtain
// a copy of the EPL at:
//
// http://www.eclipse.org/legal/epl-v10.html
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// EPL for the specific language governing permissions and limitations
// under the EPL.
//
// Also derived from the OpenFlow header files which have these copyrights:
// Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University
// Copyright (c) 2011, 2012 Open Networking Foundation

#version 4

enum macro_definitions {
    OFP_MAX_TABLE_NAME_LEN = 32,
    OFP_MAX_PORT_NAME_LEN = 16,

    OFP_TCP_PORT = 6633,
    OFP_SSL_PORT = 6633,

    OFP_ETH_ALEN = 6,

    OFP_DEFAULT_MISS_SEND_LEN = 128,

    OFP_VLAN_NONE = 0,

    OFP_FLOW_PERMANENT = 0,

    OFP_DEFAULT_PRIORITY = 0x8000,

    OFP_NO_BUFFER = 0xffffffff,

    DESCRIPTION_STRING_LEN = 256,
    SERIAL_NUMBER_LEN = 32,

    OFPQ_ALL = 0xffffffff,
    OFPQ_MAX_RATE_UNCFG = 0xffff,
    OFPQ_MIN_RATE_UNCFG = 0xffff,
};

enum ofp_message_type(wire_type=uint8_t) {
    OFPT_HELLO = 0,
    OFPT_ERROR = 1,
    OFPT_ECHO_REQUEST = 2,
    OFPT_ECHO_REPLY = 3,
    OFPT_EXPERIMENTER = 4,
    OFPT_FEATURES_REQUEST = 5,
    OFPT_FEATURES_REPLY = 6,
    OFPT_GET_CONFIG_REQUEST = 7,
    OFPT_GET_CONFIG_REPLY = 8,
    OFPT_SET_CONFIG = 9,
    OFPT_PACKET_IN = 10,
    OFPT_FLOW_REMOVED = 11,
    OFPT_PORT_STATUS = 12,
    OFPT_PACKET_OUT = 13,
    OFPT_FLOW_MOD = 14,
    OFPT_GROUP_MOD = 15,
    OFPT_PORT_MOD = 16,
    OFPT_TABLE_MOD = 17,
    OFPT_STATISTICS_REQUEST = 18,
    OFPT_STATISTICS_REPLY = 19,
    OFPT_BARRIER_REQUEST = 20,
    OFPT_BARRIER_REPLY = 21,
    OFPT_QUEUE_GET_CONFIG_REQUEST = 22,
    OFPT_QUEUE_GET_CONFIG_REPLY = 23,
    OFPT_ROLE_REQUEST = 24,
    OFPT_ROLE_REPLY = 25,
    OFPT_GET_ASYNC_REQUEST = 26,
    OFPT_GET_ASYNC_REPLY = 27,
    OFPT_SET_ASYNC = 28,
    OFPT_METER_MOD = 29,
};


enum ofp_port_config(wire_type=uint32_t, bitmask=True) {
    OFPPC_PORT_DOWN = 0x1,
    OFPPC_NO_RECV = 0x4,
    OFPPC_NO_FWD = 0x20,
    OFPPC_NO_PACKET_IN = 0x40,
};

enum ofp_port_state(wire_type=uint32_t, bitmask=True) {
    OFPPS_LINK_DOWN = 0x1,
    OFPPS_BLOCKED = 0x2,
    OFPPS_LIVE = 0x4,
};

enum ofp_port_no(wire_type=uint32_t) {
    OFPP_MAX = 0xffffff00,
    OFPP_IN_PORT = 0xfffffff8,
    OFPP_TABLE = 0xfffffff9,
    OFPP_NORMAL = 0xfffffffa,
    OFPP_FLOOD = 0xfffffffb,
    OFPP_ALL = 0xfffffffc,
    OFPP_CONTROLLER = 0xfffffffd,
    OFPP_LOCAL = 0xfffffffe,
    OFPP_ANY = 0xffffffff,
};

enum ofp_port_features(wire_type=uint32_t, bitmask=True) {
    OFPPF_10MB_HD = 0x1,
    OFPPF_10MB_FD = 0x2,
    OFPPF_100MB_HD = 0x4,
    OFPPF_100MB_FD = 0x8,
    OFPPF_1GB_HD = 0x10,
    OFPPF_1GB_FD = 0x20,
    OFPPF_10GB_FD = 0x40,
    OFPPF_40GB_FD = 0x80,
    OFPPF_100GB_FD = 0x100,
    OFPPF_1TB_FD = 0x200,
    OFPPF_OTHER = 0x400,
    OFPPF_COPPER = 0x800,
    OFPPF_FIBER = 0x1000,
    OFPPF_AUTONEG = 0x2000,
    OFPPF_PAUSE = 0x4000,
    OFPPF_PAUSE_ASYM = 0x8000,
};

enum ofp_config_flags(wire_type=uint16_t, bitmask=True) {
    OFPC_FRAG_NORMAL = 0,
    OFPC_FRAG_DROP = 1,
    OFPC_FRAG_REASM = 2,
    OFPC_FRAG_MASK = 3,
};

enum ofp_table_config(wire_type=uint32_t, bitmask=True) {
    OFPTC_DEPRECATED_MASK = 0x3,
};

enum ofp_table(wire_type=uint8_t, complete=False) {
    OFPTT_MAX = 0xfe,
    OFPTT_ALL = 0xff,
};

enum ofp_capabilities(wire_type=uint32_t, bitmask=True) {
    OFPC_FLOW_STATS = 0x1,
    OFPC_TABLE_STATS = 0x2,
    OFPC_PORT_STATS = 0x4,
    OFPC_GROUP_STATS = 0x8,
    OFPC_IP_REASM = 0x20,
    OFPC_QUEUE_STATS = 0x40,
    OFPC_PORT_BLOCKED = 0x100,
};

enum ofp_port_reason(wire_type=uint8_t) {
    OFPPR_ADD = 0,
    OFPPR_DELETE = 1,
    OFPPR_MODIFY = 2,
};

enum ofp_match_type(wire_type=uint16_t) {
    OFPMT_STANDARD = 0,
    OFPMT_OXM = 1,
};

enum ofp_oxm_class(wire_type=uint16_t) {
    OFPXMC_NXM_0 = 0,
    OFPXMC_NXM_1 = 1,
    OFPXMC_OPENFLOW_BASIC = 0x8000,
    OFPXMC_EXPERIMENTER = 0xffff,
};

enum ofp_oxm_match_fields(wire_type=uint8_t) {
  OFPXMT_OFB_IN_PORT = 0,
  OFPXMT_OFB_IN_PHY_PORT = 1,
  OFPXMT_OFB_METADATA = 2,
  OFPXMT_OFB_ETH_DST = 3,
  OFPXMT_OFB_ETH_SRC = 4,
  OFPXMT_OFB_ETH_TYPE = 5,
  OFPXMT_OFB_VLAN_VID = 6,
  OFPXMT_OFB_VLAN_PCP = 7,
  OFPXMT_OFB_IP_DSCP = 8,
  OFPXMT_OFB_IP_ECN = 9,
  OFPXMT_OFB_IP_PROTO = 10,
  OFPXMT_OFB_IPV4_SRC = 11,
  OFPXMT_OFB_IPV4_DST = 12,
  OFPXMT_OFB_TCP_SRC = 13,
  OFPXMT_OFB_TCP_DST = 14,
  OFPXMT_OFB_UDP_SRC = 15,
  OFPXMT_OFB_UDP_DST = 16,
  OFPXMT_OFB_SCTP_SRC = 17,
  OFPXMT_OFB_SCTP_DST = 18,
  OFPXMT_OFB_ICMPV4_TYPE = 19,
  OFPXMT_OFB_ICMPV4_CODE = 20,
  OFPXMT_OFB_ARP_OP = 21,
  OFPXMT_OFB_ARP_SPA = 22,
  OFPXMT_OFB_ARP_TPA = 23,
  OFPXMT_OFB_ARP_SHA = 24,
  OFPXMT_OFB_ARP_THA = 25,
  OFPXMT_OFB_IPV6_SRC = 26,
  OFPXMT_OFB_IPV6_DST = 27,
  OFPXMT_OFB_IPV6_FLABEL = 28,
  OFPXMT_OFB_ICMPV6_TYPE = 29,
  OFPXMT_OFB_ICMPV6_CODE = 30,
  OFPXMT_OFB_IPV6_ND_TARGET = 31,
  OFPXMT_OFB_IPV6_ND_SLL = 32,
  OFPXMT_OFB_IPV6_ND_TLL = 33,
  OFPXMT_OFB_MPLS_LABEL = 34,
  OFPXMT_OFB_MPLS_TC = 35,
  OFPXMT_OFP_MPLS_BOS = 36,
  OFPXMT_OFB_PBB_ISID = 37,
  OFPXMT_OFB_TUNNEL_ID = 38,
  OFPXMT_OFB_IPV6_EXTHDR = 39,
};

enum ofp_vlan_id(wire_type=uint16_t) {
    OFPVID_NONE = 0,
    OFPVID_PRESENT = 0x1000,
};

// FIXME: OF spec specified this as '9' bits, implicitly adding
// to full byte
enum ofp_ipv6exthdr_flags(wire_type=uint16_t, bitmask=True) {
    OFPIEH_NONEXT = 0x1,
    OFPIEH_ESP = 0x2,
    OFPIEH_AUTH = 0x4,
    OFPIEH_DEST = 0x8,
    OFPIEH_FRAG = 0x10,
    OFPIEH_ROUTER = 0x20,
    OFPIEH_HOP = 0x40,
    OFPIEH_UNREP = 0x80,
    OFPIEH_UNSEQ = 0x100,
};

enum ofp_action_type(wire_type=uint16_t) {
    OFPAT_OUTPUT = 0,
    OFPAT_COPY_TTL_OUT = 0xb,
    OFPAT_COPY_TTL_IN = 0xc,
    OFPAT_SET_MPLS_TTL = 0xf,
    OFPAT_DEC_MPLS_TTL = 0x10,
    OFPAT_PUSH_VLAN = 0x11,
    OFPAT_POP_VLAN = 0x12,
    OFPAT_PUSH_MPLS = 0x13,
    OFPAT_POP_MPLS = 0x14,
    OFPAT_SET_QUEUE = 0x15,
    OFPAT_GROUP = 0x16,
    OFPAT_SET_NW_TTL = 0x17,
    OFPAT_DEC_NW_TTL = 0x18,
    OFPAT_SET_FIELD = 0x19,
    OFPAT_PUSH_PBB = 0x1a,
    OFPAT_POP_PBB = 0x1b,
    OFPAT_EXPERIMENTER = 0xffff,
};

enum ofp_controller_max_len(wire_type=uint16_t, complete=False) {
    OFPCML_MAX = 0xffe5,
    OFPCML_NO_BUFFER = 0xffff,
};

// bitmask=True has been removed from the enum_args (bjlee)
enum ofp_instruction_type(wire_type=uint16_t) {
    OFPIT_GOTO_TABLE = 0x1,
    OFPIT_WRITE_METADATA = 0x2,
    OFPIT_WRITE_ACTIONS = 0x3,
    OFPIT_APPLY_ACTIONS = 0x4,
    OFPIT_CLEAR_ACTIONS = 0x5,
    OFPIT_METER = 0x6,
    OFPIT_EXPERIMENTER = 0xffff,
};

enum ofp_flow_mod_command(wire_type=uint8_t) {
    OFPFC_ADD = 0,
    OFPFC_MODIFY = 1,
    OFPFC_MODIFY_STRICT = 2,
    OFPFC_DELETE = 3,
    OFPFC_DELETE_STRICT = 4,
};

enum ofp_flow_mod_flags(wire_type=uint16_t, bitmask=True) {
    OFPFF_SEND_FLOW_REM = 0x1,
    OFPFF_CHECK_OVERLAP = 0x2,
    OFPFF_RESET_COUNTS = 0x4,
    OFPFF_NO_PKT_COUNTS = 0x8,
    OFPFF_NO_BYT_COUNTS = 0x10,
};

enum ofp_group(wire_type=uint32_t, complete=False) {
    OFPG_MAX = 0xffffff00,
    OFPG_ALL = 0xfffffffc,
    OFPG_ANY = 0xffffffff,
};

enum ofp_group_mod_command(wire_type=uint16_t) {
    OFPGC_ADD = 0,
    OFPGC_MODIFY = 1,
    OFPGC_DELETE = 2,
};


enum ofp_group_category(wire_type=uint8_t) {
    OFPGT_ALL = 0,
    OFPGT_SELECT = 1,
    OFPGT_INDIRECT = 2,
    OFPGT_FF = 3,
};

enum ofp_packet_in_reason(wire_type=uint8_t) {
    OFPR_NO_MATCH = 0,
    OFPR_ACTION = 1,
    OFPR_INVALID_TTL = 2,
};

enum ofp_flow_removed_reason(wire_type=uint8_t) {
    OFPRR_IDLE_TIMEOUT = 0,
    OFPRR_HARD_TIMEOUT = 1,
    OFPRR_DELETE = 2,
    OFPRR_GROUP_DELETE = 3,
};

enum ofp_meter(wire_type=uint32_t, complete=False) {
    OFPM_MAX = 0xffff0000,
    OFPM_SLOWPATH = 0xfffffffd,
    OFPM_CONTROLLER = 0xfffffffe,
    OFPM_ALL = 0xffffffff,
};

enum ofp_meter_band_type(wire_type=uint16_t) {
    OFPMBT_DROP = 0x1,
    OFPMBT_DSCP_REMARK = 0x2,
    OFPMBT_EXPERIMENTER = 0xffff,
};

enum ofp_meter_mod_command(wire_type=uint16_t) {
    OFPMC_ADD = 0,
    OFPMC_MODIFY = 1,
    OFPMC_DELETE = 2,
};

enum ofp_meter_flags(wire_type=uint16_t, bitmask=True) {
    OFPMF_KBPS = 0x1,
    OFPMF_PKTPS = 0x2,
    OFPMF_BURST = 0x4,
    OFPMF_STATS = 0x8,
};

enum ofp_error_code(wire_type=uint16_t) {
    OFPET_HELLO_FAILED = 0,
    OFPET_BAD_REQUEST = 1,
    OFPET_BAD_ACTION = 2,
    OFPET_BAD_INSTRUCTION = 3,
    OFPET_BAD_MATCH = 4,
    OFPET_FLOW_MOD_FAILED = 5,
    OFPET_GROUP_MOD_FAILED = 6,
    OFPET_PORT_MOD_FAILED = 7,
    OFPET_TABLE_MOD_FAILED = 8,
    OFPET_QUEUE_OP_FAILED = 9,
    OFPET_SWITCH_CONFIG_FAILED = 10,
    OFPET_ROLE_REQUEST_FAILED = 11,
    OFPET_METER_MOD_FAILED = 12,
    OFPET_TABLE_FEATURES_FAILED = 13,
    OFPET_EXPERIMENTER = 0xffff,
};

enum ofp_hello_failed_code(wire_type=uint16_t) {
    OFPHFC_INCOMPATIBLE = 0,
    OFPHFC_EPERM = 1,
};

enum ofp_bad_request_code(wire_type=uint16_t) {
    OFPBRC_BAD_VERSION = 0,
    OFPBRC_BAD_TYPE = 1,
    OFPBRC_BAD_statistics = 2,
    OFPBRC_BAD_EXPERIMENTER = 3,
    OFPBRC_BAD_EXP_TYPE = 4,
    OFPBRC_EPERM = 5,
    OFPBRC_BAD_LEN = 6,
    OFPBRC_BUFFER_EMPTY = 7,
    OFPBRC_BUFFER_UNKNOWN = 8,
    OFPBRC_BAD_TABLE_ID = 9,
    OFPBRC_IS_SLAVE = 10,
    OFPBRC_BAD_PORT = 11,
    OFPBRC_BAD_PACKET = 12,
    OFPBRC_statistics_BUFFER_OVERFLOW = 13,
};

enum ofp_bad_action_code(wire_type=uint16_t) {
    OFPBAC_BAD_TYPE = 0,
    OFPBAC_BAD_LEN = 1,
    OFPBAC_BAD_EXPERIMENTER = 2,
    OFPBAC_BAD_EXP_TYPE = 3,
    OFPBAC_BAD_OUT_PORT = 4,
    OFPBAC_BAD_ARGUMENT = 5,
    OFPBAC_EPERM = 6,
    OFPBAC_TOO_MANY = 7,
    OFPBAC_BAD_QUEUE = 8,
    OFPBAC_BAD_OUT_GROUP = 9,
    OFPBAC_MATCH_INCONSISTENT = 10,
    OFPBAC_UNSUPPORTED_ORDER = 11,
    OFPBAC_BAD_TAG = 12,
    OFPBAC_BAD_SET_TYPE = 13,
    OFPBAC_BAD_SET_LEN = 14,
    OFPBAC_BAD_SET_ARGUMENT = 15,
};

enum ofp_bad_instruction_code(wire_type=uint16_t) {
    OFPBIC_UNKNOWN_INST = 0,
    OFPBIC_UNSUP_INST = 1,
    OFPBIC_BAD_TABLE_ID = 2,
    OFPBIC_UNSUP_METADATA = 3,
    OFPBIC_UNSUP_METADATA_MASK = 4,
    OFPBIC_BAD_EXPERIMENTER = 5,
    OFPBIC_BAD_EXP_TYPE = 6,
    OFPBIC_BAD_LEN = 7,
    OFPBIC_EPERM = 8,
};

enum ofp_bad_match_code(wire_type=uint16_t) {
    OFPBMC_BAD_TYPE = 0,
    OFPBMC_BAD_LEN = 1,
    OFPBMC_BAD_TAG = 2,
    OFPBMC_BAD_DL_ADDR_MASK = 3,
    OFPBMC_BAD_NW_ADDR_MASK = 4,
    OFPBMC_BAD_WILDCARDS = 5,
    OFPBMC_BAD_FIELD = 6,
    OFPBMC_BAD_VALUE = 7,
    OFPBMC_BAD_MASK = 8,
    OFPBMC_BAD_PREREQ = 9,
    OFPBMC_DUP_FIELD = 10,
    OFPBMC_EPERM = 11,
};

enum ofp_flow_mod_failed_code(wire_type=uint16_t) {
    OFPFMFC_UNKNOWN = 0,
    OFPFMFC_TABLE_FULL = 1,
    OFPFMFC_BAD_TABLE_ID = 2,
    OFPFMFC_OVERLAP = 3,
    OFPFMFC_EPERM = 4,
    OFPFMFC_BAD_TIMEOUT = 5,
    OFPFMFC_BAD_COMMAND = 6,
    OFPFMFC_BAD_FLAGS = 7,
};

enum ofp_group_mod_failed_code(wire_type=uint16_t) {
    OFPGMFC_GROUP_EXISTS = 0,
    OFPGMFC_INVALID_GROUP = 1,
    OFPGMFC_WEIGHT_UNSUPPORTED = 2,
    OFPGMFC_OUT_OF_GROUPS = 3,
    OFPGMFC_OUT_OF_BUCKETS = 4,
    OFPGMFC_CHAINING_UNSUPPORTED = 5,
    OFPGMFC_WATCH_UNSUPPORTED = 6,
    OFPGMFC_LOOP = 7,
    OFPGMFC_UNKNOWN_GROUP = 8,
    OFPGMFC_CHAINED_GROUP = 9,
    OFPGMFC_BAD_TYPE = 10,
    OFPGMFC_BAD_COMMAND = 11,
    OFPGMFC_BAD_BUCKET = 12,
    OFPGMFC_BAD_WATCH = 13,
    OFPGMFC_EPERM = 14,
};

enum ofp_port_mod_failed_code(wire_type=uint16_t) {
    OFPPMFC_BAD_PORT = 0,
    OFPPMFC_BAD_HW_ADDR = 1,
    OFPPMFC_BAD_CONFIG = 2,
    OFPPMFC_BAD_ADVERTISE = 3,
    OFPPMFC_EPERM = 4,
};

enum ofp_table_mod_failed_code(wire_type=uint16_t) {
    OFPTMFC_BAD_TABLE = 0,
    OFPTMFC_BAD_CONFIG = 1,
    OFPTMFC_EPERM = 2,
};

enum ofp_queue_op_failed_code(wire_type=uint16_t) {
    OFPQOFC_BAD_PORT = 0,
    OFPQOFC_BAD_QUEUE = 1,
    OFPQOFC_EPERM = 2,
};

enum ofp_switch_config_failed_code(wire_type=uint16_t) {
    OFPSCFC_BAD_FLAGS = 0,
    OFPSCFC_BAD_LEN = 1,
    OFPSCFC_EPERM = 2,
};

enum ofp_role_request_failed_code(wire_type=uint16_t){
    OFPRRFC_STALE = 0,
    OFPRRFC_UNSUP = 1,
    OFPRRFC_BAD_ROLE = 2,
};

enum ofp_meter_mod_failed_code(wire_type=uint16_t) {
    OFPMMFC_UNKNOWN = 0,
    OFPMMFC_METER_EXISTS = 1,
    OFPMMFC_INVALID_METER = 2,
    OFPMMFC_UNKNOWN_METER = 3,
    OFPMMFC_BAD_COMMAND = 4,
    OFPMMFC_BAD_FLAGS = 5,
    OFPMMFC_BAD_RATE = 6,
    OFPMMFC_BAD_BURST = 7,
    OFPMMFC_BAD_BAND = 8,
    OFPMMFC_BAD_BAND_VALUE = 9,
    OFPMMFC_OUT_OF_METERS = 10,
    OFPMMFC_OUT_OF_BANDS = 11,
};

enum ofp_table_features_failed_code(wire_type=uint16_t) {
    OFPTFFC_BAD_TABLE = 0,
    OFPTFFC_BAD_METADATA = 1,
    OFPTFFC_BAD_TYPE = 2,
    OFPTFFC_BAD_LEN = 3,
    OFPTFFC_BAD_ARGUMENT = 4,
    OFPTFFC_EPERM = 5,
};

enum ofp_statistics_type(wire_type=uint16_t, request=ofp_message_type.OFPT_STATISTICS_REQUEST, reply=ofp_message_type.OFPT_STATISTICS_REPLY) {
    OFPMP_DESC = 0,
    OFPMP_FLOW = 1,
    OFPMP_AGGREGATE = 2,
    OFPMP_TABLE = 3,
    OFPMP_PORT = 4,
    OFPMP_QUEUE = 5,
    OFPMP_GROUP = 6,
    OFPMP_GROUP_DESC = 7,
    OFPMP_GROUP_FEATURES = 8,
    OFPMP_METER = 9,
    OFPMP_METER_CONFIG = 10,
    OFPMP_METER_FEATURES = 11,
    OFPMP_TABLE_FEATURES = 12,
    OFPMP_PORT_DESC = 13,
    OFPMP_EXPERIMENTER = 0xffff,
};

enum ofp_statistics_request_flags(wire_type=uint16_t, bitmask=True) {
	OFPMPF_REQ_NONE = 0x0,
    OFPMPF_REQ_MORE = 0x1,
};

enum ofp_statistics_reply_flags(wire_type=uint16_t, bitmask=True) {
	OFPMPF_REPLY_NONE = 0x0,
    OFPMPF_REPLY_MORE = 0x1,
};

enum ofp_table_feature_property_type(wire_type=uint16_t) {
    OFPTFPT_INSTRUCTIONS = 0,
    OFPTFPT_INSTRUCTIONS_MISS = 1,
    OFPTFPT_NEXT_TABLES = 2,
    OFPTFPT_NEXT_TABLES_MISS = 3,
    OFPTFPT_WRITE_ACTIONS = 4,
    OFPTFPT_WRITE_ACTIONS_MISS = 5,
    OFPTFPT_APPLY_ACTIONS = 6,
    OFPTFPT_APPLY_ACTIONS_MISS = 7,
    OFPTFPT_MATCH = 8,
    OFPTFPT_WILDCARDS = 0xa,
    OFPTFPT_WRITE_SETFIELD = 0xc,
    OFPTFPT_WRITE_SETFIELD_MISS = 0xd,
    OFPTFPT_APPLY_SETFIELD = 0xe,
    OFPTFPT_APPLY_SETFIELD_MISS = 0xf,
    OFPTFPT_EXPERIMENTER = 0xfffe,
    OFPTFPT_EXPERIMENTER_MISS = 0xffff,
};

enum ofp_group_capabilities(wire_type=uint32_t, bitmask=True) {
    OFPGFC_SELECT_WEIGHT = 0x1,
    OFPGFC_SELECT_LIVENESS = 0x2,
    OFPGFC_CHAINING = 0x4,
    OFPGFC_CHAINING_CHECKS = 0x8,
};

enum ofp_queue_property_type(wire_type=uint16_t) {
    OFPQT_MIN_RATE = 0x1,
    OFPQT_MAX_RATE = 0x2,
    OFPQT_EXPERIMENTER = 0xffff,
};

enum ofp_controller_role(wire_type=uint32_t) {
    OFPCR_ROLE_NOCHANGE = 0,
    OFPCR_ROLE_EQUAL = 1,
    OFPCR_ROLE_MASTER = 2,
    OFPCR_ROLE_SLAVE = 3,
};

enum ofp_hello_elem_type(wire_type=uint16_t) {
    OFPHET_VERSIONBITMAP = 1,
};

/* XXX rename to of_message */
struct of_header {
    uint8_t version == 0x04;
    uint8_t type == ?;
    uint16_t length;
    uint32_t xid;
};

struct of_hello_elem {
    uint16_t type == ?;
    uint16_t length;
};

struct of_hello_elem_versionbitmap : of_hello_elem {
    uint16_t type == 1;
    uint16_t length;
    list(uint32_t) bitmaps;
};

struct of_hello : of_header {
    uint8_t version;
    uint8_t type == 0;
    uint16_t length;
    uint32_t xid;
    list(of_hello_elem_t) elements;
};

struct of_echo_request : of_header {
    uint8_t version;
    uint8_t type == 2;
    uint16_t length;
    uint32_t xid;
    of_octets_t data;
};

struct of_echo_reply : of_header {
    uint8_t version;
    uint8_t type == 3;
    uint16_t length;
    uint32_t xid;
    of_octets_t data;
};

struct of_experimenter : of_header {
    uint8_t version;
    uint8_t type == 4;
    uint16_t length;
    uint32_t xid;
    uint32_t experimenter_id == ?;
    uint32_t subtype;
    of_octets_t data;
};

struct of_barrier_request : of_header {
    uint8_t version;
    uint8_t type == 20;
    uint16_t length;
    uint32_t xid;
};

struct of_barrier_reply : of_header {
    uint8_t version;
    uint8_t type == 21;
    uint16_t length;
    uint32_t xid;
};

struct of_get_config_request : of_header {
    uint8_t version;
    uint8_t type == 7;
    uint16_t length;
    uint32_t xid;
};

struct of_get_config_reply : of_header {
    uint8_t version;
    uint8_t type == 8;
    uint16_t length;
    uint32_t xid;
    uint16_t flags;
    uint16_t miss_send_len;
};

struct of_set_config : of_header {
    uint8_t version;
    uint8_t type == 9;
    uint16_t length;
    uint32_t xid;
    uint16_t flags;
    uint16_t miss_send_length;
};

struct of_table_mod : of_header {
    uint8_t version;
    uint8_t type == 17;
    uint16_t length;
    uint32_t xid;
    uint8_t table_id;
    pad(3);
    uint32_t config;
};

// port type changed from of_port_no_t into uint32_t (bjlee)
struct of_port_desc {
    uint32_t port;
    pad(4);
    of_mac_addr_t hw_addr;
    pad(2);
    of_port_name_t name;
    of_port_config_t config;
    of_port_state_t state;
    uint32_t current_features;
    uint32_t advertised_features;
    uint32_t supported_features;
    uint32_t peer_features;
    uint32_t curr_speed;
    uint32_t max_speed;
};

struct of_features_request : of_header {
    uint8_t version;
    uint8_t type == 5;
    uint16_t length;
    uint32_t xid;
};

struct of_features_reply : of_header {
    uint8_t version;
    uint8_t type == 6;
    uint16_t length;
    uint32_t xid;
    uint64_t datapath_id;
    uint32_t n_buffers;
    uint8_t n_tables;
    uint8_t auxiliary_id;
    pad(2);
    uint32_t capabilities;
    uint32_t reserved;
};

struct of_port_status : of_header {
    uint8_t version;
    uint8_t type == 12;
    uint16_t length;
    uint32_t xid;
    of_port_reason_t reason;
    pad(7);
    of_port_desc_t desc;
};

// port_no type changed from of_port_no_t into uint32_t (bjlee)
struct of_port_mod : of_header {
    uint8_t version;
    uint8_t type == 16;
    uint16_t length;
    uint32_t xid;
    uint32_t port_no;
    pad(4);
    of_mac_addr_t hw_addr;
    pad(2);
    uint32_t config;
    uint32_t mask;
    uint32_t advertise;
    pad(4);
};

struct of_oxm {
  of_oxm_class_t  oxm_class;
  uint8_t         field:7 bitmask:1;
  uint8_t         payload_length;
  of_octets_t     data;
};

// FIXME Does this need to be v4?
// removed _v3 postfix at the end of the struct name (bjlee)
// removed (align=8) at the end of the struct name (bjlee)
struct of_match {
  uint16_t type == ?;
  uint16_t length;
};

// deprecated.
struct of_match_standard : of_match {
  uint16_t type == 0;
  uint16_t length;
};

// now we should use this.
// at the end of the of_match_oxm, there is a alignment requirement to 8-byte boundary.
struct of_match_oxm : of_match {
    uint16_t type == 1;
    uint16_t length;
    list(of_oxm_t) oxm_fields;
} align(8);

// This looks like an action header, but is standalone.  See 
// ofp_table_features_prop_actions
struct of_action_id {
    uint16_t type;
    uint16_t length;
    pad(4);
};

// pad(4) is removed from the end of the of_action
// because subclasses manually adding the padding required.
struct of_action {
    uint16_t type == ?;
    uint16_t length;
};

// port type changed from of_port_no_t into uint32_t (bjlee)
struct of_action_output : of_action {
    uint16_t type == 0;
    uint16_t length;
    uint32_t port;
    uint16_t max_length;
    pad(6);
};

struct of_action_copy_ttl_out : of_action {
    uint16_t type == 11;
    uint16_t length;
    pad(4);
};

struct of_action_copy_ttl_in : of_action {
    uint16_t type == 12;
    uint16_t length;
    pad(4);
};

struct of_action_set_mpls_ttl : of_action {
    uint16_t type == 15;
    uint16_t length;
    uint8_t mpls_ttl;
    pad(3);
};

struct of_action_dec_mpls_ttl : of_action {
    uint16_t type == 16;
    uint16_t length;
    pad(4);
};

struct of_action_push_vlan : of_action {
    uint16_t type == 17;
    uint16_t length;
    uint16_t ethertype;
    pad(2);
};

struct of_action_pop_vlan : of_action {
    uint16_t type == 18;
    uint16_t length;
    pad(4);
};

struct of_action_push_mpls : of_action {
    uint16_t type == 19;
    uint16_t length;
    uint16_t ethertype;
    pad(2);
};

struct of_action_pop_mpls : of_action {
    uint16_t type == 20;
    uint16_t length;
    uint16_t ethertype;
    pad(2);
};

struct of_action_set_queue : of_action {
    uint16_t type == 21;
    uint16_t length;
    uint32_t queue_id;
};

struct of_action_group : of_action {
    uint16_t type == 22;
    uint16_t length;
    uint32_t group_id;
};

struct of_action_set_nw_ttl : of_action {
    uint16_t type == 23;
    uint16_t length;
    uint8_t nw_ttl;
    pad(3);
};

struct of_action_dec_nw_ttl : of_action {
    uint16_t type == 24;
    uint16_t length;
    pad(4);
};

struct of_action_set_field : of_action {
    uint16_t type == 25;
    uint16_t length;
    of_oxm_t field;
};

struct of_action_experimenter : of_action {
    uint16_t type == 65535;
    uint16_t length;
    uint32_t experimenter_id == ?;
    of_octets_t data;
};

struct of_action_pop_pbb : of_action {
    uint16_t type == 27;
    uint16_t length;
    pad(4);
};

struct of_action_push_pbb : of_action {
    uint16_t type == 26;
    uint16_t length;
    uint16_t ethertype;
    pad(2);
};


struct of_instruction {
    uint16_t type == ?;
    uint16_t length;
};

struct of_instruction_goto_table : of_instruction {
    uint16_t type == 1;
    uint16_t length;
    uint8_t table_id;
    pad(3);
};

struct of_instruction_write_metadata : of_instruction {
    uint16_t type == 2;
    uint16_t length;
    pad(4);
    uint64_t metadata;
    uint64_t metadata_mask;
};

struct of_instruction_write_actions : of_instruction {
    uint16_t type == 3;
    uint16_t length;
    pad(4);
    list(of_action_t) actions;
};

struct of_instruction_apply_actions : of_instruction {
    uint16_t type == 4;
    uint16_t length;
    pad(4);
    list(of_action_t) actions;
};

struct of_instruction_clear_actions : of_instruction {
    uint16_t type == 5;
    uint16_t length;
    pad(4);
};

struct of_instruction_meter : of_instruction {
    uint16_t type == 6;
    uint16_t length;
    uint32_t meter_id;
};

struct of_instruction_experimenter : of_instruction {
    uint16_t type == 65535;
    uint16_t length;
    uint32_t experimenter_id == ?;
    of_octets_t data;
};

// port number type is changed from of_port_no_t into uint32_t
// of_fm_cmd_t is changed into of_flow_mod_command_t (bjlee)
struct of_flow_mod : of_header {
    uint8_t version;
    uint8_t type == 14;
    uint16_t length;
    uint32_t xid;
    uint64_t cookie;
    uint64_t cookie_mask;
    uint8_t table_id;
    of_flow_mod_command_t _command == ?;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    uint16_t priority;
    uint32_t buffer_id;
    uint32_t out_port;
    uint32_t out_group;
    uint16_t flags;
    pad(2);
    of_match_oxm_t match;
    list(of_instruction_t) instructions;
};

// port number type is changed from of_port_no_t into uint16_t
// of_fm_cmd_t is changed into of_flow_mod_command_t (bjlee)
struct of_flow_add : of_flow_mod {
    uint8_t version;
    uint8_t type == 14;
    uint16_t length;
    uint32_t xid;
    uint64_t cookie;
    uint64_t cookie_mask;
    uint8_t table_id;
    of_flow_mod_command_t _command == 0;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    uint16_t priority;
    uint32_t buffer_id;
    uint32_t out_port;
    uint32_t out_group;
    uint16_t flags;
    pad(2);
    of_match_oxm_t match;
    list(of_instruction_t) instructions;
};

// port number type is changed from of_port_no_t into uint16_t
// of_fm_cmd_t is changed into of_flow_mod_command_t (bjlee)
struct of_flow_modify : of_flow_mod {
    uint8_t version;
    uint8_t type == 14;
    uint16_t length;
    uint32_t xid;
    uint64_t cookie;
    uint64_t cookie_mask;
    uint8_t table_id;
    of_flow_mod_command_t _command == 1;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    uint16_t priority;
    uint32_t buffer_id;
    uint32_t out_port;
    uint32_t out_group;
    uint16_t flags;
    pad(2);
    of_match_oxm_t match;
    list(of_instruction_t) instructions;
};

// port number type is changed from of_port_no_t into uint16_t
// of_fm_cmd_t is changed into of_flow_mod_command_t (bjlee)
struct of_flow_modify_strict : of_flow_mod {
    uint8_t version;
    uint8_t type == 14;
    uint16_t length;
    uint32_t xid;
    uint64_t cookie;
    uint64_t cookie_mask;
    uint8_t table_id;
    of_flow_mod_command_t _command == 2;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    uint16_t priority;
    uint32_t buffer_id;
    uint32_t out_port;
    uint32_t out_group;
    uint16_t flags;
    pad(2);
    of_match_oxm_t match;
    list(of_instruction_t) instructions;
};

// port number type is changed from of_port_no_t into uint16_t
// of_fm_cmd_t is changed into of_flow_mod_command_t (bjlee)
struct of_flow_delete : of_flow_mod {
    uint8_t version;
    uint8_t type == 14;
    uint16_t length;
    uint32_t xid;
    uint64_t cookie;
    uint64_t cookie_mask;
    uint8_t table_id;
    of_flow_mod_command_t _command == 3;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    uint16_t priority;
    uint32_t buffer_id;
    uint32_t out_port;
    uint32_t out_group;
    uint16_t flags;
    pad(2);
    of_match_oxm_t match;
    list(of_instruction_t) instructions;
};

// port number type is changed from of_port_no_t into uint16_t
// of_fm_cmd_t is changed into of_flow_mod_command_t (bjlee)
struct of_flow_delete_strict : of_flow_mod {
    uint8_t version;
    uint8_t type == 14;
    uint16_t length;
    uint32_t xid;
    uint64_t cookie;
    uint64_t cookie_mask;
    uint8_t table_id;
    of_flow_mod_command_t _command == 4;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    uint16_t priority;
    uint32_t buffer_id;
    uint32_t out_port;
    uint32_t out_group;
    uint16_t flags;
    pad(2);
    of_match_oxm_t match;
    list(of_instruction_t) instructions;
};

// port number type is changed from of_port_no_t into uint32_t (bjlee)
struct of_bucket {
    uint16_t length;
    uint16_t weight;
    uint32_t watch_port;
    uint32_t watch_group;
    pad(4);
    list(of_action_t) actions;
};

struct of_group_mod : of_header {
    uint8_t version;
    uint8_t type == 15;
    uint16_t length;
    uint32_t xid;
    uint16_t command;
    uint8_t group_category;
    pad(1);
    uint32_t group_id;
    list(of_bucket_t) buckets;
};

// port number type is changed from of_port_no_t into uint32_t (bjlee)
struct of_packet_out : of_header {
    uint8_t version;
    uint8_t type == 13;
    uint16_t length;
    uint32_t xid;
    uint32_t buffer_id;
    uint32_t input_port;
    uint16_t actions_length;
    pad(6);
    list(of_action_t) actions;
    of_octets_t data;
};

struct of_packet_in : of_header {
    uint8_t version;
    uint8_t type == 10;
    uint16_t length;
    uint32_t xid;
    uint32_t buffer_id;
    uint16_t total_length;
    uint8_t reason;
    uint8_t table_id;
    uint64_t cookie;
    of_match_oxm_t match;
    pad(2);
    of_octets_t data; 
};

struct of_flow_removed : of_header {
    uint8_t version;
    uint8_t type == 11;
    uint16_t length;
    uint32_t xid;
    uint64_t cookie;
    uint16_t priority;
    uint8_t reason;
    uint8_t table_id;
    uint32_t duration_sec;
    uint32_t duration_nsec;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    uint64_t packet_count;
    uint64_t byte_count;
    of_match_oxm_t match;
};

// rate and burst_size is removed from this struct because this is a header
struct of_meter_band {
    uint16_t        type == ?;
    uint16_t        length;
    uint32_t        rate;
    uint32_t        burst_size;
};

struct of_meter_band_drop : of_meter_band {
    uint16_t        type == 1;
    uint16_t        length;
    uint32_t        rate;
    uint32_t        burst_size;
    pad(4);
};

struct of_meter_band_dscp_remark : of_meter_band {
    uint16_t        type == 2;
    uint16_t        length;
    uint32_t        rate;
    uint32_t        burst_size;
    uint8_t         prec_level;
    pad(3);
};

struct of_meter_band_experimenter : of_meter_band {
    uint16_t        type == 65535;
    uint16_t        length;
    uint32_t        rate;
    uint32_t        burst_size;
    uint32_t        experimenter_id;
};

struct of_meter_mod : of_header {
    uint8_t version;
    uint8_t type == 29;
    uint16_t length;
    uint32_t xid;
    uint16_t command;
    uint16_t flags;
    uint32_t meter_id;
    list(of_meter_band_t) meters;
};

struct of_error : of_header {
    uint8_t version;
    uint8_t type == 1;
    uint16_t length;
    uint32_t xid;
    uint16_t error_code;
    uint16_t subcode;
    of_octets_t data;
};

// STATS ENTRIES: flow, table, port, queue, group stats, group desc stats

struct of_flow_stats_entry {
    uint16_t length;
    uint8_t table_id;
    pad(1);
    uint32_t duration_sec;
    uint32_t duration_nsec;
    uint16_t priority;
    uint16_t idle_timeout;
    uint16_t hard_timeout;
    uint16_t flags;
    pad(4);
    uint64_t cookie;
    uint64_t packet_count;
    uint64_t byte_count;
    of_match_oxm_t match;
    list(of_instruction_t) instructions;
};


struct of_table_stats_entry {
    uint8_t table_id;
    pad(3);
    uint32_t active_count;
    uint64_t lookup_count;
    uint64_t matched_count;
};

// port number type is changed from of_port_no_t into uint32_t (bjlee)
// This struct def is different with the spec. we should check it out.
struct of_port_stats_entry {
    uint32_t port_number;
    pad(4);
    uint64_t receive_packets;
    uint64_t transmit_packets;
    uint64_t receive_bytes;
    uint64_t transmit_bytes;
    uint64_t receive_dropped;
    uint64_t transmit_dropped;
    uint64_t receive_errors;
    uint64_t transmit_errors;
    uint64_t receive_frame_errors;
    uint64_t receive_overrun_errors;
    uint64_t receive_CRC_errors;
    uint64_t collisions;
    uint32_t duration_sec;
    uint32_t duration_nsec;
};

// port number type is changed from of_port_no_t into uint32_t (bjlee)
struct of_queue_stats_entry {
    uint32_t port_number;
    uint32_t queue_id;
    uint64_t transmit_bytes;
    uint64_t transmit_packets;
    uint64_t transmit_errors;
    uint32_t duration_sec;
    uint32_t duration_nsec;
};

struct of_bucket_counter {
    uint64_t packet_count;
    uint64_t byte_count;
};

struct of_group_stats_entry {
    uint16_t length;
    pad(2);
    uint32_t group_id;
    uint32_t ref_count;
    pad(4);
    uint64_t packet_count;
    uint64_t byte_count;
    uint32_t duration_sec;
    uint32_t duration_nsec;
    list(of_bucket_counter_t) bucket_stats;
};

struct of_group_desc_stats_entry {
    uint16_t length;
    uint8_t type;
    pad(1);
    uint32_t group_id;
    list(of_bucket_t) buckets;
};

// STATS: 
//  Desc, flow, agg, table, port, queue, group, group_desc, group_feat, experi


// of_statistics is introduced (bjlee)
struct of_statistics : of_header {
	uint8_t version;
  	uint8_t type == ?;
  	uint16_t length;
  	uint32_t xid;
};

struct of_statistics_request : of_statistics {
    uint8_t version;
    uint8_t type == 18;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == ?;
    uint16_t flags == 0;
    pad(4);
};

struct of_statistics_reply : of_statistics {
    uint8_t version;
    uint8_t type == 19;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == ?;
    uint16_t flags == 0;
    pad(4);
};

struct of_statistics_desc_request : of_statistics_request {
    uint8_t version;
    uint8_t type == 18;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 0;
    uint16_t flags;
    pad(4);
};

struct of_statistics_desc_reply : of_statistics_reply {
    uint8_t version;
    uint8_t type == 19;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 0;
    uint16_t flags;
    pad(4);
    of_desc_str_t manufacturer_description;
    of_desc_str_t hardware_description;
    of_desc_str_t software_description;
    of_serial_num_t serial_number;
    of_desc_str_t datapath_description;
};

// port number type is changed from of_port_no_t into uint32_t (bjlee)
struct of_statistics_flow_request : of_statistics_request {
    uint8_t version;
    uint8_t type == 18;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 1;
    uint16_t flags;
    pad(4);
    uint8_t table_id;
    pad(3);
    uint32_t out_port;
    uint32_t out_group;
    pad(4);
    uint64_t cookie;
    uint64_t cookie_mask;
    of_match_oxm_t match;
};

struct of_statistics_flow_reply : of_statistics_reply {
    uint8_t version;
    uint8_t type == 19;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 1;
    uint16_t flags;
    pad(4);
    list(of_flow_stats_entry_t) entries;
};

// port number type is changed from of_port_no_t into uint32_t (bjlee)
struct of_statistics_aggregate_request : of_statistics_request {
    uint8_t version;
    uint8_t type == 18;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 2;
    uint16_t flags;
    pad(4);
    uint8_t table_id;
    pad(3);
    uint32_t out_port;
    uint32_t out_group;
    pad(4);
    uint64_t cookie;
    uint64_t cookie_mask;
    of_match_oxm_t match;
};

struct of_statistics_aggregate_reply : of_statistics_reply {
    uint8_t version;
    uint8_t type == 19;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 2;
    uint16_t flags;
    pad(4);
    uint64_t packet_count;
    uint64_t byte_count;
    uint32_t flow_count;
    pad(4);
};

struct of_statistics_table_request : of_statistics_request {
    uint8_t version;
    uint8_t type == 18;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 3;
    uint16_t flags;
    pad(4);
};

struct of_statistics_table_reply : of_statistics_reply {
    uint8_t version;
    uint8_t type == 19;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 3;
    uint16_t flags;
    pad(4);
    list(of_table_stats_entry_t) entries;
};

// FIXME: These are padded to 8 byte align beyond the length indicated

struct of_table_feature_property {
    uint16_t         type;
    uint16_t         length;
};

// FIXME Check if instruction_t is right for ids here
struct of_table_feature_property_instructions : of_table_feature_property {
    uint16_t         type == 0;
    uint16_t         length;
    list(of_instruction_t)   instruction_ids;
};

struct of_table_feature_property_instructions_miss : of_table_feature_property {
    uint16_t         type == 1;
    uint16_t         length;
    list(of_instruction_t)   instruction_ids;
};

struct of_table_feature_property_next_tables : of_table_feature_property {
    uint16_t         type == 2;
    uint16_t         length;
    list(uint8_t) next_table_ids;
};

struct of_table_feature_property_next_tables_miss : of_table_feature_property {
    uint16_t         type == 3;
    uint16_t         length;
    list(uint8_t) next_table_ids;
};

struct of_table_feature_property_write_actions : of_table_feature_property {
    uint16_t         type == 4;
    uint16_t         length;
    list(of_action_id_t) action_ids;
};

struct of_table_feature_property_write_actions_miss : of_table_feature_property {
    uint16_t         type == 5;
    uint16_t         length;
    list(of_action_id_t) action_ids;
};

struct of_table_feature_property_apply_actions : of_table_feature_property {
    uint16_t         type == 6;
    uint16_t         length;
    list(of_action_id_t) action_ids;
};

struct of_table_feature_property_apply_actions_miss : of_table_feature_property {
    uint16_t         type == 7;
    uint16_t         length;
    list(of_action_id_t) action_ids;
};

struct of_table_feature_property_match : of_table_feature_property {
    uint16_t         type == 8;
    uint16_t         length;
    list(uint32_t)   oxm_ids;
};

struct of_table_feature_property_wildcards : of_table_feature_property {
    uint16_t         type == 10;
    uint16_t         length;
    list(uint32_t)   oxm_ids;
};

struct of_table_feature_property_write_setfield : of_table_feature_property {
    uint16_t         type == 12;
    uint16_t         length;
    list(uint32_t)   oxm_ids;
};

struct of_table_feature_property_write_setfield_miss : of_table_feature_property {
    uint16_t         type == 13;
    uint16_t         length;
    list(uint32_t)   oxm_ids;
};

struct of_table_feature_property_apply_setfield : of_table_feature_property {
    uint16_t         type == 14;
    uint16_t         length;
    list(uint32_t)   oxm_ids;
};

struct of_table_feature_property_apply_setfield_miss : of_table_feature_property {
    uint16_t         type == 15;
    uint16_t         length;
    list(uint32_t)   oxm_ids;
};

struct of_table_feature_property_experimenter : of_table_feature_property {
    uint16_t         type == 65534;
    uint16_t         length;
    uint32_t         experimenter_id;
    uint32_t         subtype;
    of_octets_t      experimenter_data;
};

struct of_table_feature_property_experimenter_miss : of_table_feature_property {
    uint16_t         type == 65535;
    uint16_t         length;
    uint32_t         experimenter_id;
    uint32_t         subtype;
    of_octets_t      experimenter_data;
};

struct of_table_features {
    uint16_t length;
    uint8_t table_id;
    pad(5);
    of_table_name_t name;
    uint64_t metadata_match;
    uint64_t metadata_write;
    uint32_t config;
    uint32_t max_entries;
    list(of_table_feature_property_t) properties;
};

struct of_meter_features {
    uint32_t    max_meter;
    uint32_t    band_types;
    uint32_t    capabilities;
    uint8_t     max_bands;
    uint8_t     max_color;
    pad(2);
};

// of_port_no_t --> uint32_t (bjlee)
struct of_statistics_port_request : of_statistics_request {
    uint8_t version;
    uint8_t type == 18;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 4;
    uint16_t flags;
    pad(4);
    uint32_t port_no;
    pad(4);
};

struct of_statistics_port_reply : of_statistics_reply {
    uint8_t version;
    uint8_t type == 19;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 4;
    uint16_t flags;
    pad(4);
    list(of_port_stats_entry_t) entries;
};

// of_port_no_t --> uint32_t (bjlee)
struct of_statistics_queue_request : of_statistics_request {
    uint8_t version;
    uint8_t type == 18;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 5;
    uint16_t flags;
    pad(4);
    uint32_t port_no;
    uint32_t queue_id;
};

struct of_statistics_queue_reply : of_statistics_reply {
    uint8_t version;
    uint8_t type == 19;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 5;
    uint16_t flags;
    pad(4);
    list(of_queue_stats_entry_t) entries;
};

struct of_statistics_group_request : of_statistics_request {
    uint8_t version;
    uint8_t type == 18;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 6;
    uint16_t flags;
    pad(4);
    uint32_t group_id;
    pad(4);
};

struct of_statistics_group_reply : of_statistics_reply {
    uint8_t version;
    uint8_t type == 19;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 6;
    uint16_t flags;
    pad(4);
    list(of_group_stats_entry_t) entries;
};

struct of_statistics_group_desc_request : of_statistics_request {
    uint8_t version;
    uint8_t type == 18;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 7;
    uint16_t flags;
    pad(4);
};

struct of_statistics_group_desc_reply : of_statistics_reply {
    uint8_t version;
    uint8_t type == 19;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 7;
    uint16_t flags;
    pad(4);
    list(of_group_desc_stats_entry_t) entries;
};

struct of_statistics_group_features_request : of_statistics_request {
    uint8_t version;
    uint8_t type == 18;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 8;
    uint16_t flags;
    pad(4);
};

struct of_statistics_group_features_reply : of_statistics_reply {
    uint8_t version;
    uint8_t type == 19;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 8;
    uint16_t flags;
    pad(4);
    uint32_t types;
    uint32_t capabilities;
    uint32_t max_groups_all;
    uint32_t max_groups_select;
    uint32_t max_groups_indirect;
    uint32_t max_groups_ff;
    uint32_t actions_all;
    uint32_t actions_select;
    uint32_t actions_indirect;
    uint32_t actions_ff;
};

struct of_statistics_meter_request : of_statistics_request {
    uint8_t version;
    uint8_t type == 18;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 9;
    uint16_t flags;
    pad(4);
    uint32_t meter_id;
    pad(4);
};

struct of_meter_band_stats {
  uint64_t packet_band_count;
  uint64_t byte_band_count;
};

struct of_meter_stats {
  uint32_t meter_id;
  uint16_t length;
  pad(6);
  uint32_t flow_count;
  uint64_t packet_in_count;
  uint64_t byte_in_count;
  uint32_t duration_sec;
  uint32_t duration_nsec;
  list(of_meter_band_stats_t) band_stats;
};

struct of_statistics_meter_reply : of_statistics_reply {
    uint8_t version;
    uint8_t type == 19;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 9;
    uint16_t flags;
    pad(4);
    list(of_meter_stats_t) entries;
};

struct of_statistics_meter_config_request : of_statistics_request {
    uint8_t version;
    uint8_t type == 18;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 10;
    uint16_t flags;
    pad(4);
    uint32_t meter_id;
    pad(4);
};

struct of_statistics_meter_config_reply : of_statistics_reply {
    uint8_t version;
    uint8_t type == 19;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 10;
    uint16_t flags;
    pad(4);
    list(of_meter_band_t) entries;
};

// FIXME stats added to get things working
struct of_statistics_meter_features_request : of_statistics_request {
    uint8_t version;
    uint8_t type == 18;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 11;
    uint16_t flags;
    pad(4);
};

// FIXME stats added to get things working
struct of_statistics_meter_features_reply : of_statistics_reply {
    uint8_t version;
    uint8_t type == 19;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 11;
    uint16_t flags;
    pad(4);
    of_meter_features_t features;
};

// FIXME stats added to get things working
struct of_statistics_table_features_request : of_statistics_request {
    uint8_t version;
    uint8_t type == 18;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 12;
    uint16_t flags;
    pad(4);
    list(of_table_features_t) entries;
};

// FIXME stats added to get things working
struct of_statistics_table_features_reply : of_statistics_reply {
    uint8_t version;
    uint8_t type == 19;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 12;
    uint16_t flags;
    pad(4);
    list(of_table_features_t) entries;
};

// FIXME stats added to get things working
struct of_statistics_port_desc_request : of_statistics_request {
    uint8_t version;
    uint8_t type == 18;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 13;
    uint16_t flags;
    pad(4);
};

// FIXME stats added to get things working
struct of_statistics_port_desc_reply : of_statistics_reply {
    uint8_t version;
    uint8_t type == 19;
    uint16_t length;
    uint32_t xid;
    uint16_t statistics_type == 13;
    uint16_t flags;
    pad(4);
    list(of_port_desc_t) entries;
};

struct of_statistics_experimenter_request : of_statistics_request {
  uint8_t version;
  uint8_t type == 18;
  uint16_t length;
  uint32_t xid;
  uint16_t statistics_type == 0xffff;
  uint16_t flags;
  pad(4);
  uint32_t experimenter_id;
  uint32_t experiment_type;
  of_octets_t data;
};

struct of_statistics_experimenter_reply : of_statistics_reply {
  uint8_t version;
  uint8_t type == 19;
  uint16_t length;
  uint32_t xid;
  uint16_t statistics_type == 0xffff;
  uint16_t flags;
  pad(4);
  uint32_t experimenter_id;
  uint32_t experiment_type;
  of_octets_t data;
}; 

// END OF STATS (statistics) OBJECTS

struct of_queue_property {
    uint16_t type == ?;
    uint16_t length;
    pad(4);
};

struct of_queue_property_min_rate : of_queue_property {
    uint16_t type == 1;
    uint16_t length;
    pad(4);
    uint16_t rate;
    pad(6);
};

struct of_queue_property_max_rate : of_queue_property {
    uint16_t type == 2;
    uint16_t length;
    pad(4);
    uint16_t rate;
    pad(6);
};

struct of_queue_property_experimenter : of_queue_property {
    uint16_t type == 65535;
    uint16_t length;
    pad(4);
    uint32_t experimenter_id == ?;
    pad(4);
    of_octets_t data;
};

// of_port_no_t --> uint32_t (bjlee)
struct of_packet_queue {
    uint32_t queue_id;
    uint32_t port;
    uint16_t length;
    pad(6);
    list(of_queue_property_t) properties;
};

// of_port_no_t --> uint32_t (bjlee)
struct of_queue_get_config_request : of_header {
    uint8_t version;
    uint8_t type == 22;
    uint16_t length;
    uint32_t xid;
    uint32_t port;
    pad(4);
};

// of_port_no_t --> uint32_t (bjlee)
struct of_queue_get_config_reply : of_header {
    uint8_t version;
    uint8_t type == 23;
    uint16_t length;
    uint32_t xid;
    uint32_t port;
    pad(4);
    list(of_packet_queue_t) queues;
};

struct of_role_request : of_header {
    uint8_t version;
    uint8_t type == 24;
    uint16_t length;
    uint32_t xid;
    uint32_t role;
    pad(4);
    uint64_t generation_id;
};

struct of_role_reply : of_header {
    uint8_t version;
    uint8_t type == 25;
    uint16_t length;
    uint32_t xid;
    of_octets_t data;
};

////////////////////////////////////////////////////////////////
// FIXME understand async; where do bitmasks live?
// Determine bitmap type for masks below.
// DOCUMENT masks where uint32_t[0] is interest for equal/master
//   while uint32_t[1] is interest for slave
////////////////////////////////////////////////////////////////

struct of_get_async_request : of_header {
    uint8_t version;
    uint8_t type == 26;
    uint16_t length;
    uint32_t xid;
    uint32_t packet_in_mask_equal_master;
    uint32_t packet_in_mask_slave;
    uint32_t port_status_mask_equal_master;
    uint32_t port_status_mask_slave;
    uint32_t flow_removed_mask_equal_master;
    uint32_t flow_removed_mask_slave;
};

struct of_get_async_reply : of_header {
    uint8_t version;
    uint8_t type == 27;
    uint16_t length;
    uint32_t xid;
    uint32_t packet_in_mask_equal_master;
    uint32_t packet_in_mask_slave;
    uint32_t port_status_mask_equal_master;
    uint32_t port_status_mask_slave;
    uint32_t flow_removed_mask_equal_master;
    uint32_t flow_removed_mask_slave;
};

struct of_set_async : of_header {
    uint8_t version;
    uint8_t type == 28;
    uint16_t length;
    uint32_t xid;
    uint32_t packet_in_mask_equal_master;
    uint32_t packet_in_mask_slave;
    uint32_t port_status_mask_equal_master;
    uint32_t port_status_mask_slave;
    uint32_t flow_removed_mask_equal_master;
    uint32_t flow_removed_mask_slave;
};
